/* Copyright (c) 2025 Harun
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef PWLEDGER_SECRET_H
#define PWLEDGER_SECRET_H

#include <cassert>
#include <cstddef>
#include <span>
#include <sodium.h>

namespace pwledger {

// to enforce usage of safe alternatives of malloc, memzero ...
// CRTP
template <class CustomSecureAllocator>
struct SecureAllocator {};  // maybe SecureCharTAllocator
                            // if not gonna be used elsewhere but SecureString

// std::string doesn't actually erase its memory when it goes
// out of scope or gets reassigned. Instead, it simply marks that
// memory as available for reuse. So the information is still
// there, so assume that you store password or something sensitive
// in std::string, the memory can be paged out, can be find in
// swap memory or worse in the disk which is non-volatile storage
// so the sensitive information will hang around for a while
// custom allocator to std::string doesn't solve the security problems
// due to std::string can make hidden copies in some operations
// the C++ standard allows implementations to use something called
// the Small String Optimization (SSO). This means that short strings
// might be stored directly inside the string object itself,
// not in allocated memory at all. Even the custom allocator never even
// sees this data, so it can't zero it when the string is destroyed.
class Secret {
  // about the class, these are always true:
  // 1- single ownership (no copies and move invalidates the source)
  // 2- all sensitive bytes live in sodium-secured memory
  // 3- no implicit conversions, no stream operators, no accidental formatting
  // 4- allocation failure is fatal or explicit
  // 5- partial construction never leaks memory
public:
  friend class Secret_readaccess;
  friend class Secret_writeaccess;

  // may cause segfault when directly wrapped around in an access guard
  // Secret() noexcept = default;
  explicit Secret(std::size_t size) { allocate(size); }

  ~Secret() noexcept { wipe_and_free(); }
  Secret(Secret&& other) noexcept
    : _M_data(other._M_data),
      _M_size(other._M_size)
  {
    other._M_data = nullptr;
    other._M_size = 0;
  }

  Secret& operator=(Secret&& other) noexcept {
    if (this != &other) {
      if (_M_data) {
        sodium_free(_M_data);
      }
      _M_data = other._M_data;
      _M_size = other._M_size;
      other._M_data = nullptr;
      other._M_size = 0;
    }
    return *this;
  }

  // copying to/from is not allowed (see Secret-1)
  // according to rule of 5 we need explicit definitions
  // see: https://en.cppreference.com/w/cpp/language/rule_of_three.html
  Secret(const Secret&) = delete;
  Secret& operator=(const Secret&) = delete;

  // not thread-safe
  void clear() noexcept {
    if (_M_data) {
      sodium_mprotect_readwrite(_M_data);
      sodium_memzero(_M_data, _M_size);
      sodium_mprotect_noaccess(_M_data);
    }
  }

  template <typename F>
  decltype(auto) with_read_access(F&& f) const {
    Secret_readaccess guard(*this);y
    return std::forward<F>(f)(guard.get());
  }

  template <typename F>
  decltype(auto) with_write_access(F&& f) {
    Secret_writeaccess guard(*this);
    return std::forward<F>(f)(guard.get());
  }

private:
  char *_M_data = nullptr;
  std::size_t _M_size = 0;

  void allocate(std::size_t size) {
    assert(size > 0);
    _M_data = static_cast<char*>(sodium_malloc(size));
    if (!_M_data) { std::abort(); } // FAIL FAST
    _M_size = size;
    sodium_mprotect_noaccess(_M_data);
  }

  void wipe_and_free() noexcept {
    if (_M_data) {
      sodium_free(_M_data);
      _M_data = nullptr;
      _M_size = 0;
    }
  }
};

// std::span is better than C-strings because
// secrets can be passwords, private keys, API tokens ...
// so to avoid assumptions like: null-terminated string,
// UTF-8 validity, printable characters

class Secret_readaccess {
public:
  Secret_readaccess(const Secret &s) : sec(s) { sodium_mprotect_readonly(sec._M_data); }
  ~Secret_readaccess() noexcept { sodium_mprotect_noaccess(sec._M_data); }
  [[nodiscard]] std::span<const char> get() const noexcept { return {sec._M_data, sec._M_size}; }

  // if copy would be allowed:
  // auto a = Secret_readaccess(secret);
  // auto b = a;  // two destructors, double relock
  Secret_readaccess(const Secret_readaccess&) = delete;
  Secret_readaccess& operator=(const Secret_readaccess&) = delete;
  Secret_readaccess(Secret_readaccess&&) = delete;
  Secret_readaccess& operator=(Secret_readaccess&&) = delete;
private:
  const Secret &sec;
};

class Secret_writeaccess {
public:
  Secret_writeaccess(Secret &s) : sec(s) { sodium_mprotect_readwrite(sec._M_data); }
  ~Secret_writeaccess() noexcept { sodium_mprotect_noaccess(sec._M_data); }
  [[nodiscard]] std::span<char> get() noexcept { return {sec._M_data, sec._M_size}; }

  // if copy would be allowed:
  // auto a = Secret_writeaccess(secret);
  // auto b = a;  // two destructors, double relock
  Secret_writeaccess(const Secret_writeaccess&) = delete;
  Secret_writeaccess& operator=(const Secret_writeaccess&) = delete;
  Secret_writeaccess(Secret_writeaccess&&) = delete;
  Secret_writeaccess& operator=(Secret_writeaccess&&) = delete;
private:
  Secret &sec;
};

// DOCUMENT: Secret_writeaccess w(secret);
//       Secret_readaccess r(secret); // overrides protection
// document “no nested access” (acceptable) or
// track state (complex) or debug-assert in development builds

// DOCUMENT: not thread-safe, requires external synchronization
// DOCUMENT: Secret_readaccess r(secret);
//           secret = Secret(32); // moves, frees old memory
//           r.get();             // dangling reference

// problems that secure_string can't solve
// - OS may still snapshot memory
// - crash dumps may still contain secrets
// - debuggers see everything
// to reduce debugger attachment:
// linux: prctl(PR_SET_DUMPABLE, 0); // from <sys/prctl.h>
// ! should be called before secret exists
// macOS: enable Hardened Runtime
// disable debugger entitlement
// windows: IsDebuggerPresent, CheckRemoteDebuggerPresent
// These are weak (easily bypassed), but still useful to:
// - detect accidental debugging
// - fail fast in production
// minimize time-in-memory
// bad:
// Secret pwd = read_password();
// lots of code
// authenticate(pwd);
// good:
// with_secret_from_input([](Secret& pwd) {
//    authenticate(pwd);
// });
// memory protection:
// sodium_mprotect_readwrite(secret.data());
// use secret
// sodium_mprotect_noaccess(secret.data());
// Disable core dumps:
// #include <sys/resource.h>
// rlimit r{0, 0};
// setrlimit(RLIMIT_CORE, &r);
}  // namespace pwledger

#endif  // PWLEDGER_SECRET_H
